## Ссылки, функции, О-нотация, бинарный поиск

### Ссылки и указатели

Вспомним, что такое указатель и ссылка и в чем они различаются.

Ссылка - альтернативное имя объекта в памяти. Ссылки связываются с областью памяти, поэтому являются константами.

Указатель - объект, значением которого служат адрес другого объекта.

Как говорилось на лекции, ссылку можно воспринимать как указатель, который не нужно разыменовывать.

Основные различия указателей и ссылок в C++:
1. Ссылки по определению константные, указатели - нет. 
```C++
  int* px; // OK
  px = &x; // OK
  px = &y; // OK
  
  int& ry = y; 
  ry = x; // OK, ry всё также алиас на y
```
2. Нельзя создать ссылку, не проинициализировав её (ведь она константная). Укаазатель можно.
```C++
  int& rx; // CE
  int* px; // OK
```
3. Существует арифметика указателей, но не существует арифметики ссылок.
```C++
  bool* array = new bool[2];
  array[0] = true;
  array[1] = false;
  std::cout << *(array + 1); // OK, выведет 0, то есть false

  bool x = 'a';
  bool& px = x;
  ++px; // CE
```
4. Нельзя создать ссылку на void, указатель - можно. `void*` используем, когда не хотим учитывать тип объекта, на который указываем.
5. [Нельзя создавать массивы ссылок](https://stackoverflow.com/questions/1164266/why-are-arrays-of-references-illegal), но можно создавать массивы указателей.
6. Нельзя создать ссылку на ссылку, но можно создать указатель на указатель (вы встречали это в двумерных динамических массивах).

### O-нотация
*Воспоминания из матана* Пусть $f(x)$ и $g(x)$ - две функции, определенные в некоторой проколотой окрестности точки $x_{0}$, причем в этой окрестности $g$ не обращается в ноль. Говорят, что:

$f$ является «O» большим от $g$ при $x \rightarrow x_0$, если существует такая константа $C>0$, что для всех $x$ из некоторой окрестности точки $x_{0}$ имеет место неравенство $|f(x)| \le C |g(x)|$. Обозначение: $f(x) = O(g(x))$.

Заметим, что $O(const * x + const) = O(x), x = O(x^2)$ (на самом деле $x \in O(x^2)$, но мы упростим запись).

О-нотация используется для оценки сложности алгоритмов. Мы оцениваем временную сложность алгоритма через количество операций, необходимых для выполнения алгоритма, в зависимости от входных данных. 

Например, на вход подаётся массив размера $N$. 
- Какая сложность у получения элемента массива по индексу? $O(1)$, ведь нам достаточно всего одной операции.
- Допустим, мы хотим вывести все элементы массива, а затем снова пройтись по всему массиву и занулить все элементы. Тогда мы сделаем $O(2N)$ операций, а сложностью алгоритма будем считать $O(N)$.

### Левосторонний и правосторонний бинарный поиск

Вспомним, что правосторонний поиск по ключу $x$ находит такой наибольший индекс $i$, что $array[i] \le x$. Левосторонний поиск по ключу $x$ находит такой наименьший индекс $i$, что $array[i] \ge x$.
```C++
int BinarySearchLeft(const int* arr, const int arr_size, const int key) {
  int left_board = -1;
  int right_board = arr_size;
  int middle;

  while (left_board < right_board - 1) {
    middle = left_board + (right_board - left_board) / 2;
    if (arr[middle] < key) {
      left_board = middle;
    } else {
      right_board = middle;
    }
  }

  return right_board;
}

int BinarySearchRight(const int* arr, const int arr_size, const int key) {
  int left_board = -1;
  int right_board = arr_size;
  int middle;

  while (left_board < right_board - 1) {
    middle = left_board + (right_board - left_board) / 2;
    if (arr[middle] <= key) {
      left_board = middle;
    } else {
      right_board = middle;
    }
  }

  return left_board;
}
```

### Как теперь сдавать задачи?
- Запрещено писать логику в main(). В main() оставляем ввод всех входных данных, затем передаем их в соответствующие функции. Каждая функция должна выполнять одну конкретную задачу, обладать "одной отвественностью".
- Часто вы будете встречать задачи с длинным вводом и вовыдом. В таких случаях вставляйте преамбулу
```C++
std::ios_base::sync_with_stdio(false);
std::cin.tie(nullptr);
std::cout.tie(nullptr);
```

Прочитайте [статью](https://zhxilin.github.io/post/sync_with_stdio_false_cin_tie_null/), которая объясняет, что происходит в каждой строчке.

### Домашнее задание

[Ссылка](https://contest.yandex.ru/contest/40711/standings) на четвертый еженедельный контест.
